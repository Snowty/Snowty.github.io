<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>筱筱汀的碎碎念</title>
    <description>欢迎聆听我的碎碎念😯</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 25 Sep 2018 17:54:46 +0800</pubDate>
    <lastBuildDate>Tue, 25 Sep 2018 17:54:46 +0800</lastBuildDate>
    <generator>Jekyll v3.4.3</generator>
    
      <item>
        <title>计算机基础相关的问题（数据结构、数据库、密码学等）</title>
        <description>&lt;h3 id=&quot;cs与bs&quot;&gt;&lt;a href=&quot;https://m.jb51.net/article/56605.htm&quot;&gt;C/S与B/S&lt;/a&gt;&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;C/S&lt;/code&gt;结构，即Client/Server(客户机/服务器)结构，通过将任务合理分配到Client端和Server端，降低了系统的通讯开销，可以充分利用两端
硬件环境的优势。早期的软件系统多以此作为首选设计标准。&lt;/p&gt;

    &lt;p&gt;优点：&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2.1 C/S架构的界面和操作可以很丰富。
2.2 安全性能可以很容易保证，实现多层认证也不难。
2.3 由于只有一层交互，因此响应速度较快。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;缺点：&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2.4 适用面窄，通常用于局域网中。
2.5 用户群固定。由于程序需要安装才可使用，因此不适合面向一些不可知的用户。
2.6 维护成本高，发生一次升级，则所有客户端的程序都需要改变。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;B/S&lt;/code&gt;结构，即Browser/Server(浏览器/服务器)结构，用户界面完全通过WWW浏览器实现，一部分事务逻辑在前端实现，但是主要事务逻辑在服务器端实现&lt;/p&gt;

    &lt;p&gt;优点：&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1）客户端无需安装，有Web浏览器即可。
2）BS架构可以直接放在广域网上，通过一定的权限控制实现多客户访问的目的，交互性较强。
3）BS架构无需升级多个客户端，升级服务器即可。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;缺点：&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1）在跨浏览器上，BS架构不尽如人意。
2）表现要达到CS程序的程度需要花费不少精力。
3）在速度和安全性上需要花费巨大的设计成本，这是BS架构的最大问题。
4）客户端服务器端的交互是请求-响应模式，通常需要刷新页面，这并不是客户乐意看到的。（在Ajax风行后此问题得到了一定程度的缓解）
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;数据库&quot;&gt;数据库&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;数据库的ACID:
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;原子性（Atomicity）:事务是一个不可再分割的工作单元，事务中的操作要么都发生，要么都不发生
一致性（Consistency）:事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。
隔离性（Isolation）:多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。
持久性（Durability）:在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/LemonTreey/article/details/53067437&quot;&gt;数据库的死锁&lt;/a&gt;：&lt;/p&gt;

    &lt;p&gt;原因：&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.  系统资源不足
2.  进程运行推进的顺序不合适
3.  资源分配不当
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;四个必要条件：&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.  互斥条件：一个资源每次只能被一个进程使用
2.  请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
3.  不可剥夺条件
3.  循环等待条件
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;预防与解除：避免产生的四个条件&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.  按同一顺序访问对象
2.  避免事务中的用户交互
3.  保持事务简短并在同一个批处理中
4.  使用低隔离级别
5.  使用绑定连接
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;密码学&quot;&gt;密码学&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html&quot;&gt;RSA算法原理（欧拉定理）&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html&quot;&gt;RSA算法原理&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://www.anquanke.com/post/id/84632&quot;&gt;【技术分享】CTF中RSA的常见攻击方法&lt;/a&gt;（没有细看，有时间的话要仔细看看看啊！！！！&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;数据结构&quot;&gt;数据结构&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/21923021&quot;&gt;KMP&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;二叉树：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.  完全二叉树：若设二叉树的深度为h，除第h层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层所有的结点都连续集中在最左边，这就是完全二叉树
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/JVxie/p/4859889.html&quot;&gt;堆&lt;/a&gt;：堆是完全二叉树&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/Antineutrino/article/details/6763722&quot;&gt;前缀、中缀、后缀表达式&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/posts/2018/09/计算机基础//前缀表达式.jpeg&quot; height=&quot;300&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;选B&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;线性表：&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;插入和删除的时间复杂度为：O(n),其余操作（如访问）为O(1)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 22 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/</guid>
        
        <category>计算机基础</category>
        
        
      </item>
    
      <item>
        <title>Linux与安全基础</title>
        <description>&lt;h3 id=&quot;linux基础&quot;&gt;Linux基础&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/yangbodong22011/article/details/50753906&quot;&gt;/etc/passwd 和 /etc/shadows 详解&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;passwd文件举例
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;对应字段
&lt;img src=&quot;/images/posts/2018/09/安全相关//passwd.png&quot; height=&quot;500&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;shadow文件
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root:$6$X9iEgIhv$wGtrUhjiNRp72LgCTzC1qdi.myfSU9S5nqsfr.m1KInUFoeOUBN73AmMy5sTe91biJLdHgsoimZQzeD9EvGlv1:16769:0:99999:7:::
daemon:*:16547:0:99999:7:::
bin:*:16547:0:99999:7:::
sys:*:16547:0:99999:7:::
sync:*:16547:0:99999:7:::
games:*:16547:0:99999:7:::
man:*:16547:0:99999:7:::
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;/images/posts/2018/09/安全相关//shadow.png&quot; height=&quot;500&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;软连接&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;文件分为：
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;用户数据（user data）:即文件数据块（data block），记录文件真实内容的地方
元数据（metadata）：文件的附加属性，如文件大小、创建时间、所有者信息。其中的`inode`号即为文件的唯一标志
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
        &lt;p&gt;&lt;img src=&quot;/images/posts/2018/09/安全相关//inode.jpg&quot; height=&quot;150&quot; width=&quot;300&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;硬链接（hard link）：同一个文件使用了多个别名，即一个inode号对应多个文件名，可由link或ln创建
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;文件有相同的 inode 及 data block；
只能对已存在的文件进行创建；
不能交叉文件系统进行硬链接的创建；
不能对目录进行创建，只可对文件创建；
删除一个硬链接文件并不影响其他有相同 inode 号的文件。
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;软链接（soft link or symbolic link）：若文件用户数据块中存放的内容是另一文件的路径名的指向，则该文件就是软链接。软链接就是一个普通文件，只是数据块内容有点特殊。软链接有着自己的 inode 号以及用户数据块
&lt;img src=&quot;/images/posts/2018/09/安全相关//softlink.jpg&quot; height=&quot;150&quot; width=&quot;300&quot; /&gt;
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;软链接有自己的文件属性及权限等；
可对不存在的文件或目录创建软链接；
软链接可交叉文件系统；
软链接可对文件或目录创建；
创建软链接时，链接计数 i_nlink 不会增加；
删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;shell
    &lt;ul&gt;
      &lt;li&gt;新浪的一道笔试题：
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;找出web日志中响应时间小于0.03的客户端IP并去重：
201.158.69.116 - - [03/Jan/2013:21:17:20 -0600] &quot;GET /api/insert?test=1&quot; &quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.97 Safari/537.11&quot; &quot;114.229.23.58&quot; &quot;0.015&quot;
201.158.69.116 - - [03/Jan/2013:21:17:20 -0600] &quot;GET /api/insert?test=1&quot; &quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.97 Safari/537.11&quot; &quot;114.229.23.58&quot; &quot;0.002&quot;
201.158.69.116 - - [03/Jan/2013:21:17:20 -0600] &quot;GET /api/insert?test=1&quot; &quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.97 Safari/537.11&quot; &quot;114.229.23.58&quot; &quot;0.039&quot;
201.158.69.118 - - [03/Jan/2013:21:17:20 -0600] &quot;GET /api/insert?test=1&quot; &quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.97 Safari/537.11&quot; &quot;114.229.23.58&quot; &quot;0.015&quot;
201.158.69.119 - - [03/Jan/2013:21:17:20 -0600] &quot;GET /api/insert?test=1&quot; &quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.97 Safari/537.11&quot; &quot;114.229.23.58&quot; &quot;0.015&quot;
201.158.69.119 - - [03/Jan/2013:21:17:20 -0600] &quot;GET /api/insert?test=1&quot; &quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.97 Safari/537.11&quot; &quot;114.229.23.58&quot; &quot;0.030&quot;
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
        &lt;p&gt;解析：&lt;/p&gt;
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cat log | awk '{if($NF&amp;lt;0.03) print $1}' | sort -u     //这样写的话最后一位是str类型，无法做数值比较，应该是扑街了
cat log | awk 'BEGIN{FS=&quot;\&quot;&quot;} $8 &amp;gt; 0.03 {print $1}' | awk '{print $1}'      //大神指导我的第一版本，以&quot;\&quot;&quot;为分隔符
cat log | awk '{if(strtonum(substr($NF,2,5))&amp;lt;0.03) print $1}' | sort -u     //大神指导的第二版本，很优雅啦~
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/renzhuang/articles/6733461.html&quot;&gt;进程与线程的区别&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;进程是指程序执行时的一个实例。线程是进程的一个实体。&lt;/li&gt;
      &lt;li&gt;进程——资源分配的最小单位；线程——程序执行的最小单位，处理机调度和分配的单位。&lt;/li&gt;
      &lt;li&gt;进程拥有独立的堆栈空间和数据段，所以每当启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段,但是安全性高;线程拥有独立的堆栈空间，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，比进程更节俭，开销比较小，切换速度也比进程快，效率高，但是一个线程死掉就等于整个进程死掉。&lt;/li&gt;
      &lt;li&gt;通信机制上面，正因为进程之间互不干扰，相互独立，进程的通信机制相对很复杂，譬如管道，信号，消息队列，共享内存，套接字等通信机制，而线程由于共享数据段所以通信机制很方便&lt;/li&gt;
      &lt;li&gt;一个线程可以创建另一个线程。线程是不分父子线程的，一个线程创建另一个线程，尽管第一个线程已经结束，第二个线程还是可以照常运行。&lt;/li&gt;
      &lt;li&gt;运行在一个进程里的线程共享该进程的整个虚拟地址空间&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/q_l_s/article/details/51789245&quot;&gt;同一进程中的线程究竟共享哪些资源&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;其他&quot;&gt;其他&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u013761036/article/details/52268500&quot;&gt;DLL劫持&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/bytxl/article/details/11552353&quot;&gt;IPSec&lt;/a&gt;:为 IP 数据报提供了高质量的、可互操作的、基于密码学的安全性。特定的通信方之间在 IP 层通过加密与数据源验证等方式，来保证数据报在网络上传输时的私有性、完整性、真实性和防重放。&lt;/p&gt;
    &lt;pre&gt;&lt;code class=&quot;language- &quot;&gt;私有性（Confidentiality ）指对用户数据进行加密保护，用密文的形式传送。
完整性（Data integrity ）指对接收的数据进行验证，以判定报文是否被篡改。
真实性（Data authentication ）指验证数据源，以保证数据来自真实的发送者。
防重放（Anti-replay ）指防止恶意用户通过重复发送捕获到的数据包所进行的攻击，即接收方会拒绝旧的或重复的数据包。
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 22 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/Linux%E4%B8%8E%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/Linux%E4%B8%8E%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/</guid>
        
        <category>计算机基础</category>
        
        
      </item>
    
      <item>
        <title>用户行为日志分析</title>
        <description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;

&lt;p&gt;慕课网&lt;a href=&quot;https://coding.imooc.com/class/112.html&quot;&gt;《以慕课网日志分析为例 进入大数据 Spark SQL 的世界》&lt;/a&gt;笔记。&lt;/p&gt;

&lt;h3 id=&quot;日志数据内容&quot;&gt;日志数据内容&lt;/h3&gt;
&lt;p&gt;1）访问的系统属性：操纵系统、浏览器等&lt;/p&gt;

&lt;p&gt;2）访问特征：点击的url、从哪个url跳转过来（referer）、页面上的停留时间&lt;/p&gt;

&lt;p&gt;3）访问信息：session_id、访问ip信息（城市信息）等&lt;/p&gt;

&lt;h3 id=&quot;离线数据处理流程&quot;&gt;离线数据处理流程&lt;/h3&gt;
&lt;p&gt;1）数据采集：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Flume：将日志从一个地方采集到另一个地方，如web日志到HDFS
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2）数据清洗：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;脏数据：spark、Hive、MapReduce等，清洗完的数据可以放在HDFS中
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3）数据处理：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;按照需求进行相应业务逻辑的统计和分析，spark、Hive、MapReduce等
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;4）处理结果入库&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;结果可以存放到RDBMS、NoSQL
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;5）数据的可视化展示&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;通过图像化展示的方式展现出来：饼图、柱状图、地图、折线图

ECharts、HUE、Zeppelin
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/2018/09/日志分析//离线处理.png&quot; height=&quot;350&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一般的日志处理方式，需要进行分区，如：d，h，m5（每5min）&lt;/p&gt;
</description>
        <pubDate>Thu, 20 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/sparkSQL/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/sparkSQL/</guid>
        
        <category>大数据</category>
        
        
      </item>
    
      <item>
        <title>hadoop相关基础</title>
        <description>&lt;h3 id=&quot;概述&quot;&gt;概述&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;狭义的hadoop：
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HDFS:分布式存储
MapReduce:分布式计算
YARN:资源调度
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;广义hadoop生态圈:&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Flume进行数据采集
Spark/MR/Hive等进行数据处理
HDFS/HBase进行数据存储
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;&lt;img src=&quot;/images/posts/2018/09/hadoop//hadoop生态.png&quot; height=&quot;280&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HDFS架构：
&lt;img src=&quot;/images/posts/2018/09/hadoop//hdfs架构.png&quot; height=&quot;400&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1 个Master（即为NameNode/NN）带N个Slaves（DataNode/DN）&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;1个文件会被拆分成多个Block，例:blocksize 128M&lt;/p&gt;

    &lt;p&gt;NN:&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1)负责客户端请求的响应
2)负责元数据（文件的名称、副本洗漱、block存放的DN）的管理
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;DN：&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1）存储用户的文件对应的数据块（Block）
2) 要定期向NN发送心跳信息，汇报本身及所有的block信息，健康状况
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;启动HDFS:&lt;code class=&quot;highlighter-rouge&quot;&gt;sbin/start-dfs.sh&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;验证是否启动成功：&lt;code class=&quot;highlighter-rouge&quot;&gt;jps&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;浏览器：&lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:50070&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;停止HDFS:   &lt;code class=&quot;highlighter-rouge&quot;&gt;sbin/stop-dfs.sh&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HDFS优点：高容错、批处理、适合大数据处理、可部署在廉价机器上
缺点：延迟大、不适合小文件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;YARN架构&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/posts/2018/09/hadoop//YARN架构.png&quot; height=&quot;400&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1 RM(Resource Manager)+ N NM(Node Manager)&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;Resource Manager的职责： 一个集群active状态的RM只有一个，负责整个集群的资源管理和调度&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1） 处理客户端的请求（启动/杀死）
2） 启动/监控ApplicationMaster（一个作业对应一个AM）
3） 监控NM
4） 系统的资源分配和调度
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;NodeManager：整个集群中有N个，负责单个节点的资源管理和使用以及task的运行情况&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1）定期向RM汇报本节点的资源使用情况和各个Container的运行状态
2）接收并处理RM的container启停的各种命令
3）单个节点的资源管理和任务管理
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;ApplicationMaseter：每个应用/作业对应一个，负责应用程序的管理&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1）数据切分
2）为应用程序向RM申请资源（container），并分配给内部任务
3）与NM通信并启停task，task是运行在container中的
4）task的监控和容错
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;Container：&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;对任务运行情况的描述:CPU、memory、环境变量
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;YARN执行流程：&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1) 用户向YARN提交作业
2）RM为该作业分配第一个container（启动AM）
3) RM会与对应的NM通信，要求NM在这个container上启动应用程序的AM
4）AM首先向RM注册，然后AM将为各个任务申请资源，并监控运行情况
5）AM采用轮训的方式通过RPC协议向RM申请和领取资源
6）AM申请到资源以后，便和相应的NM通信，要求NM启动任务
7）NM启动我们作业对应的task

&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;&lt;img src=&quot;/images/posts/2018/09/hadoop//YARN执行流程.png&quot; height=&quot;400&quot; width=&quot;600&quot; /&gt;
启动yarn：&lt;code class=&quot;highlighter-rouge&quot;&gt;sbin/start-yarn.sh&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:8088&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Hive:构建在hadoop上面的数据仓库，使用hdfs进行数据存储，使用MR进行计算。
    用于离线数据处理，底层的执行引擎有MR、Tez、Spark，支持多种不同的压缩/存储格式,统一的元数据管理（可与SparkSQL等共享数据）
&lt;img src=&quot;/images/posts/2018/09/hadoop//hive架构.png&quot; height=&quot;400&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;基本操作：&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;创建表：create table hive_wordcount(context string);
加载数据到hive：load data local inpath './hello.txt' into table hive_wordcount;
统计：select word,count(1) from hive_wordcount lateral view explode(split(context,'\t')) wc as word group by word;
(lateral view explode():把每行记录按照指定分隔符进行拆解) 
hive sql 提交执行以后会生成MR作业，并在yarn上运行
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;spark：数据处理框架，快：基于内存，DAG执行引擎，基于线程的模型（有线程池）&lt;/li&gt;
  &lt;li&gt;MR的局限性：
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1) 代码繁琐
2）只能够支持map和reduce方法
3）执行效率低下
4）不适合迭代多次、交互式、流式的处理
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;架构多样化：&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1) 批处理（离线）：MapReduce、Hive、Pig
2）流式处理（实时）：Storm、JStorm
3）交互式计算：Impala
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Spark与Hadoop对比：
&lt;img src=&quot;/images/posts/2018/09/hadoop//hadoop与spark对比.png&quot; height=&quot;400&quot; width=&quot;600&quot; /&gt;
&lt;img src=&quot;/images/posts/2018/09/hadoop//内部对比.png&quot; height=&quot;400&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;MR与Spark对比：存储位置不同（磁盘与内存）
&lt;img src=&quot;/images/posts/2018/09/hadoop//mr与spark.png&quot; height=&quot;400&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;Hadoop+Spark
&lt;img src=&quot;/images/posts/2018/09/hadoop//hadoop+spark.png&quot; height=&quot;200&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Tue, 18 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/hadoop/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/hadoop/</guid>
        
        <category>大数据</category>
        
        
      </item>
    
      <item>
        <title>HTTP报文解析</title>
        <description>&lt;h3 id=&quot;详解&quot;&gt;详解&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u010256388/article/details/68491509&quot;&gt;HTTP请求行、请求头、请求体详解&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/2018/04/HTTP报文//1.jpg&quot; height=&quot;400&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;

&lt;p&gt;①&lt;a href=&quot;http://www.runoob.com/http/http-methods.html&quot;&gt;请求方法(HTTP 1.1中支持)&lt;/a&gt;：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/u010529455/article/details/42918639&quot;&gt;解析HTTP协议六种请求方法,get,head,put,delete,post有什么区别&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;get：提交的数据最多1024字节&lt;/li&gt;
      &lt;li&gt;head：只请求页面的首部&lt;/li&gt;
      &lt;li&gt;post:数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。&lt;/li&gt;
      &lt;li&gt;put：与post相似，但是会指定资源的存放位置&lt;/li&gt;
      &lt;li&gt;options：允许客户端查看服务器的性能,获取当前URL所支持的方法&lt;/li&gt;
      &lt;li&gt;delete：删除某一资源，返回的状态码（200：ok，202：Accepted，204：No Content）&lt;/li&gt;
      &lt;li&gt;trace：回显服务器收到的请求，主要用于测试或诊断&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.web-tinker.com/article/20055.html&quot;&gt;connect&lt;/a&gt;：动态切换为隧道的代理，把服务器作为跳板，让服务器代替用户去访问其它网页，之后把数据原原本本的返回给用户。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;②URL地址&lt;/p&gt;

&lt;p&gt;③协议名称及版本号&lt;/p&gt;

&lt;p&gt;④&lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_HTTP_header_fields&quot;&gt;HTTP报文头&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;一些标准报文头：
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Accept:text/plain&lt;/code&gt;:告诉服务器，客户端接受什么类型的相应,属性值可以为一个或者多个&lt;a href=&quot;https://en.wikipedia.org/wiki/Media_type&quot;&gt;MIME&lt;/a&gt;类型的值&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Accept-Charset: utf-8&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Accept-Encoding: gzip, deflate&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Accept-Language: en-US&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Access-Control-Request-Method: GET&lt;/code&gt;:&lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-origin_resource_sharing&quot;&gt;Cross-origin resource sharing&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Host&lt;/code&gt;:The domain name of the server&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Connection: keep-alive&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Origin: http://www.example-social-network.com&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Content-Type: application/x-www-form-urlencoded&lt;/code&gt;:Media type of the body of the request(post and put)&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Cookie&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Referer&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Cache-Control: no-cache&lt;/code&gt;:让服务端将对应请求返回的响应内容不要在客户端缓存&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/12.0&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Content-Length: 348&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;X-Forwarded-For: client1, proxy1, proxy2&lt;/code&gt;:&lt;a href=&quot;http://blog.csdn.net/caiqiiqi/article/details/72852083&quot;&gt;绕过服务器IP地址过滤&lt;/a&gt;,tcp层伪造源IP比较困难可以在http层进行伪造&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;X-Frame-Options: deny&lt;/code&gt;:&lt;a href=&quot;http://blog.csdn.net/wangnan537/article/details/76599962&quot;&gt;防止网页被Frame&lt;/a&gt;,点劫持防御。&lt;code class=&quot;highlighter-rouge&quot;&gt;deny&lt;/code&gt;表示页面不能被嵌入到任何iframe或frame中。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;⑤报文体：将一个页面表单中的组件值通过param1=value1&amp;amp;param2=value2的键值对形式编码成一个格式化串，它承载多个请求参数的数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/2018/04/HTTP报文//2.jpg&quot; height=&quot;200&quot; width=&quot;400&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;状态码&quot;&gt;&lt;a href=&quot;https://www.jianshu.com/p/49ebc4a78474&quot;&gt;状态码&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;HTTP的响应状态码由3位数字构成，根据第一位数字的值可以把HTTP响应分为5类：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1xx：代表响应已经被服务器接受，需要继续处理&lt;/li&gt;
  &lt;li&gt;2xx：这一类型的状态码，表示该HTTP请求已经被服务器成功接受和理解。&lt;/li&gt;
  &lt;li&gt;3xx：重定向标识。表示客户端需要采取进一步操作才能完成请求，重定向地址会在本次响应报文的消息报头中给出，其字段名为Location。&lt;/li&gt;
  &lt;li&gt;4xx：客户端错误。这类状态码表示发送请求的客户端发生了错误，妨碍了服务器的请求处理。&lt;/li&gt;
  &lt;li&gt;5xx：服务器错误。其表示服务器在处理请求的过程中有错误或者异常状态发生，也可能是服务器当前的硬件资源无法完成对客户端的请求处理。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;常见状态码：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;200 OK：客户端请求成功。&lt;/li&gt;
  &lt;li&gt;400 Bad Request：客户端请求有语法错误，不能被服务器所理解。&lt;/li&gt;
  &lt;li&gt;401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。&lt;/li&gt;
  &lt;li&gt;403 Forbidden：服务器收到请求，但是拒绝提供服务。&lt;/li&gt;
  &lt;li&gt;404 Not Found：请求资源不存在，举个例子：输入了错误的URL。&lt;/li&gt;
  &lt;li&gt;500 Internal Server Error：服务器发生不可预期的错误。&lt;/li&gt;
  &lt;li&gt;503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 02 Apr 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/04/HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/04/HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4/</guid>
        
        <category>计算机基础</category>
        
        
      </item>
    
      <item>
        <title>Hack the box 的一些write up</title>
        <description>&lt;h3 id=&quot;celestial&quot;&gt;&lt;a href=&quot;https://www.hackthebox.eu/home/machines/profile/130&quot;&gt;Celestial&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;nmap -sC -sV 10.10.10.85&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;发现3000端口开了node.js服务&lt;/li&gt;
  &lt;li&gt;查找到node.js反序列化RCE，&lt;a href=&quot;https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/&quot;&gt;Exploiting Node.js deserialization bug for Remote Code Execution&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;反弹shell后查看到&lt;code class=&quot;highlighter-rouge&quot;&gt;/home/sun/Documents/user.txt&lt;/code&gt;里面是用户flag，同目录下有个&lt;code class=&quot;highlighter-rouge&quot;&gt;script.py&lt;/code&gt;
&lt;img src=&quot;/images/posts/2018/03/HTB/85/1.png&quot; height=&quot;80&quot; width=&quot;280&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;查看当前进程里面有没有python脚本，发现root正在运行这个脚本，猜测可能是个crontab定时任务
&lt;img src=&quot;/images/posts/2018/03/HTB/85/2.png&quot; height=&quot;200&quot; width=&quot;800&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;将&lt;code class=&quot;highlighter-rouge&quot;&gt;script.py&lt;/code&gt;的内容改为反弹shell语句，成功反弹root shell&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;crontab -l&lt;/code&gt;查看定时任务：
&lt;img src=&quot;/images/posts/2018/03/HTB/85/3.png&quot; height=&quot;100&quot; width=&quot;800&quot; /&gt;
[参考文章]&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/xiaoxiaoleo/p/8379977.html&quot;&gt;Linux提权思路&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.waitalone.cn/linux-shell-rebound-under-way.html&quot;&gt;Linux下反弹shell方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 22 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/03/HTB/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/03/HTB/</guid>
        
        <category>sec</category>
        
        
      </item>
    
      <item>
        <title>文字框选相关问题(R-CNN,SPPNET,Fast R-CNN,Faster R-CNN,CTPN,YOLO )</title>
        <description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;搜集了别人总结的文章，加上自己做的小笔记，供复习查看用。&lt;/p&gt;

&lt;h3 id=&quot;数据集&quot;&gt;数据集&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/tzutalin/labelImg&quot;&gt;图片框选与标注工具&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/2018/03/框选//1.jpg&quot; height=&quot;350&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ImageNet ILSVC 2012:    标定每张图片中物体的类别。一千万图像，1000类&lt;/p&gt;

    &lt;p&gt;PASCAL VOC 2007:        标定每张图片中，物体的类别和位置，一万图像，20类
 （VOC物体检测任务：如果某数据集包含了20个物体类别，则还需要加上背景类，总共21类）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;r-cnn&quot;&gt;R-CNN&lt;/h3&gt;

&lt;p&gt;这个博主写的文章，真的是很清晰啊，把所有不清楚的名词都解释好了~&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/23006190?refer=xiaoleimlnote&quot;&gt;RCNN-将CNN引入目标检测的开山之作&lt;/a&gt;
&lt;a href=&quot;http://blog.csdn.net/WoPawn/article/details/52133338&quot;&gt;R-CNN论文详解&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/2018/03/框选//RCNN.png&quot; height=&quot;200&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;步骤：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.  候选区域生成： 采用Selective Search的方法在一张图像生成1K~2K个候选区域(Region Proposal)
    + 此阶段搜索出来的候选框，大小各不相同，需要缩放(crop/warp)成227*227的固定尺寸

2.  特征提取： 将每个Region Proposal输入到CNN，将CNN的fc7层的输出作为特征
    + 网络设计：使用Alexnet，5层卷积2个全连接，f7的神经元个数都是4096，最后每个输入候选框图片都能得到一个4096维的特征向量
    + 网络有监督预训练阶段（ImageNet）：标签较少，所以使用Alexnet直接初始化参数，SGD,lr = 0.001
    + fine-tuning阶段（PASCAL VOC）：将上面预训练的最后一层替换成N+1个输出（N类再加一个背景，此处为21）。SGD，lr = 0.001，batch_size = 128(32个正样本，96个负样本)
    + 正负样本：一张图有2000个候选框，而人工标注只有正确的BBX。所以候选框与BBX的重叠区域IoU大于0.5，则视为正样本

3.  类别判断： 特征送入每一类的SVM分类器，判别是否属于该类 
    + SVM训练阶段：
        + 检测窗口只包含部分物体，IoU的阈值为0.3，则小于0.3时为负样本。
        + 一旦CNN f7层特征被提取出来，则为每个物体类训练一个svm分类器。
        + 当我们用CNN提取2000个候选框，可以得到2000*4096这样的特征向量矩阵
        + 然后只需要把这样的一个矩阵与svm权值矩阵4096*N点乘(N为分类类别数目，因为我们训练的N个svm，每个svm包含了4096个权值w)。

        + 位置精修：目标检测问题的衡量标准是重叠面积：许多看似准确的检测结果，往往因为候选框不够准确，重叠面积很小。故需要一个位置精修步骤

    + 测试阶段：
        + 使用selective search的方法在测试图片上提取2000个region propasals ，将每个region proposals归一化到227x227，然后再CNN中正向传播，将最后一层得到的特征提取出来。
        + 然后对于每一个类别，使用为这一类训练的SVM分类器对提取的特征向量进行打分，得到测试图片中对于所有region proposals的对于这一类的分数，
        + 再使用贪心的非极大值抑制（NMS）去除相交的多余的框。再对这些框进行canny边缘检测，就可以得到bounding-box(then B-BoxRegression)。

4.  位置精修： 使用回归器精细修正候选框位置 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;相关的知识点：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ selective search：将图像分割成小区域（1~2K个），按照规则（纹理、颜色等）合并相邻的两个区域，直到整个图像合并成一个区域位置。输出所有曾经存在过的区域，所谓候选区域
+ 重叠度（IOU）：两个BBX的重叠度，即矩形框A、B的重叠面积占A、B并集的面积比例
+ 非极大值抑制（NMS）：一张图片中找出N个可能是同一物体的矩形框，需要判别哪些框是没有用的。例如在行人检测中，滑动窗口经提取特征，经分类器分类识别后，每个窗口都会得到一个分数。但是滑动窗口会导致很多窗口与其他窗口存在包含或者大部分`交叉`的情况。这时就需要用到NMS来选取那些邻域里分数最高（是行人的概率最大），并且抑制那些分数低的窗口。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/2018/03/框选//IOU.png&quot; height=&quot;250&quot; width=&quot;400&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;sppnet&quot;&gt;SPPNet&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24774302?refer=xiaoleimlnote&quot;&gt;SPPNet-引入空间金字塔池化改进RCNN&lt;/a&gt;
&lt;img src=&quot;/images/posts/2018/03/CTPN//4.jpg&quot; height=&quot;280&quot; width=&quot;400&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;总体流程依旧是： Selective Search得到候选区域-&amp;gt;CNN提取RoI特征-&amp;gt;类别判断-&amp;gt;位置精修&lt;/li&gt;
  &lt;li&gt;但是在faeture map上提取ROI特征，只需要在整张图像上做一次卷积，提高了效率
&lt;img src=&quot;/images/posts/2018/03/CTPN//5.jpg&quot; height=&quot;80&quot; width=&quot;400&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;原始图像的RoI如何映射到特征图：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24780433&quot;&gt;原始图片中的ROI如何映射到到feature map?&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;感受野(receptive field,某一层&lt;code class=&quot;highlighter-rouge&quot;&gt;输出结果&lt;/code&gt;中一个元素所对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;输入层&lt;/code&gt;的区域大小)的计算：
        &lt;ul&gt;
          &lt;li&gt;卷基层的输出：
  &lt;code class=&quot;highlighter-rouge&quot;&gt;output= ( input - kernel size + 2*padding ) / stride + 1&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;卷积层的输入：
  &lt;code class=&quot;highlighter-rouge&quot;&gt;input = （output  - 1）* stride - 2*padding + kernel size&lt;/code&gt;
  &lt;img src=&quot;/images/posts/2018/03/CTPN//6.jpg&quot; height=&quot;400&quot; width=&quot;500&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;上面只是给出了 前一层在后一层的感受野，如何计算最后一层在原始图片上的感受野呢？ 从后向前级联一下就可以了（先计算最后一层到倒数第二层的感受野，再计算倒数第二层到倒数第三层的感受野，依次从后往前推导就可以了）&lt;/li&gt;
      &lt;li&gt;SPP-net 是把原始ROI的左上角和右下角 映射到 feature map上的两个对应点。 有了feature map上的两队角点就确定了 对应的 feature map 区域(下图中橙色)。 
  &lt;img src=&quot;/images/posts/2018/03/CTPN//7.jpg&quot; height=&quot;300&quot; width=&quot;500&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;RoI在特征图上对应的特征区域的维度不满足全连接层的输入要求
    &lt;ul&gt;
      &lt;li&gt;空间金字塔池化：假设原图输入是224x224，对于conv5出来后的输出是13x13x256的，可以理解成有256个这样的filter，每个filter对应一张13x13的reponse map。如果像下图那样将reponse map分成1x1(金字塔底座)，2x2(金字塔中间)，4x4（金字塔顶座）三张子图，分别做&lt;code class=&quot;highlighter-rouge&quot;&gt;max pooling&lt;/code&gt;后，出来的特征就是(16+4+1)x256 维度。如果原图的输入不是224x224，出来的特征依然是(16+4+1)x256维度。这样就实现了不管图像尺寸如何 池化n 的输出永远是 （16+4+1）x256 维度。 
&lt;img src=&quot;/images/posts/2018/03/CTPN//3.jpg&quot; height=&quot;280&quot; width=&quot;400&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;fast-r-cnn&quot;&gt;Fast R-CNN&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24780395?refer=xiaoleimlnote&quot;&gt;Fast R-CNN&lt;/a&gt;
&lt;img src=&quot;/images/posts/2018/03/CTPN//8.jpg&quot; height=&quot;600&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;joint training （SVM分类，bbox回归 联合起来在CNN阶段训练）把最后一层的Softmax换成两个，一个是对区域的分类Softmax（包括背景），另一个是对bounding box的微调。这个网络有两个输入，一个是整张图片，另一个是候选proposals算法产生的可能proposals的坐标。&lt;/li&gt;
  &lt;li&gt;提出了一个RoI层，算是SPP的变种，SPP是pooling成多个固定尺度，RoI只pooling到单个固定的尺度 （论文通过实验得到的结论是多尺度学习能提高一点点mAP，不过计算量成倍的增加，故单尺度训练的效果更好。）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;faster-r-cnn&quot;&gt;Faster R-CNN&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24916624?refer=xiaoleimlnote&quot;&gt;Faster R-CNN&lt;/a&gt;
&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31426458&quot;&gt;一文读懂Faster R-CNN&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/2018/03/CTPN//10.jpg&quot; height=&quot;300&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;将特征抽取(feature extraction)，proposal提取，bounding box regression(rect refine)，classification都整合在了一个网络中
&lt;img src=&quot;/images/posts/2018/03/CTPN//9.jpg&quot; height=&quot;600&quot; width=&quot;800&quot; /&gt;
分为以下四步：&lt;/li&gt;
  &lt;li&gt;Conv layers。作为一种CNN网络目标检测方法，Faster R-CNN首先使用一组基础的conv+relu+pooling层提取image的feature maps。该feature maps被共享用于后续RPN层和全连接层。&lt;/li&gt;
  &lt;li&gt;Region Proposal Networks。RPN网络用于生成region proposals。该层通过softmax判断anchors属于foreground或者background，再利用bounding box regression修正anchors获得精确的proposals。&lt;/li&gt;
  &lt;li&gt;Roi Pooling。该层收集输入的feature maps和proposals，综合这些信息后提取proposal feature maps，送入后续全连接层判定目标类别。&lt;/li&gt;
  &lt;li&gt;Classification。利用proposal feature maps计算proposal的类别，同时再次bounding box regression获得检测框最终的精确位置。
&lt;img src=&quot;/images/posts/2018/03/CTPN/11.jpg&quot; height=&quot;400&quot; width=&quot;800&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;yolo&quot;&gt;YOLO&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24916786&quot;&gt;图解YOLO&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;ctpn&quot;&gt;CTPN&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://slade-ruan.me/2017/10/22/text-detection-ctpn/&quot;&gt;论文阅读与实现–CTPN&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;对比与小结&quot;&gt;对比与小结&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/35887527/answer/73048322&quot;&gt;知乎&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;mapmean-average-precision&quot;&gt;mAP(mean average precision)&lt;/h3&gt;

</description>
        <pubDate>Wed, 21 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/03/%E6%96%87%E5%AD%97%E6%A1%86%E9%80%89/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/03/%E6%96%87%E5%AD%97%E6%A1%86%E9%80%89/</guid>
        
        <category>AI</category>
        
        
      </item>
    
      <item>
        <title>Java反序列化</title>
        <description>&lt;h3 id=&quot;定义&quot;&gt;定义&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.vulbox.com/knowledge/detail/?id=11&quot;&gt;深入理解JAVA反序列化漏洞&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;序列化  ：把Java对象转换为字节序列的过程便于保存在内存、文件、数据库中，ObjectOutputStream类的writeObject()方法可以实现序列化。&lt;/li&gt;
  &lt;li&gt;反序列化：是指把字节序列恢复为Java对象的过程，ObjectInputStream类的readObject()方法用于反序列化。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/2018/03/java//definition.png&quot; height=&quot;150&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;序列化与反序列化是让Java对象脱离Java运行环境的一种手段，可以有效的实现多平台之间的通信、对象持久化存储。主要应用在以下场景：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HTTP：多平台之间的通信，管理等

RMI：远程方法调用(Remote Method Invocation),让在某个java虚拟机上的对象像调用本地对象一样调用另一个java虚拟机中的对象上的方法。RMI的传输100%基于反序列化,默认端口是1099。

JMX：Java Management Extensions,让程序有被管理的功能，中间件软件WebLogic的管理页面就是基于JMX开发的，而JBoss则整个系统都基于JMX构架。 ​

JDNI(Java Naming and Directory Interface):提供了查找和访问各种命名和目录服务的通用、统一的接口,支持的对象有DNS、LDAP、 CORBA 对象服务、RMI 等。简单的来说就是RMI注册的服务可以让 JNDI 应用程序来访问，调用。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/2018/03/java//rmi.png&quot; height=&quot;500&quot; width=&quot;400&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;漏洞历史&quot;&gt;漏洞历史&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;15年的Apache Commons Collections 反序列化远程命令执行漏洞，其当初影响范围包括：WebSphere、JBoss、Jenkins、WebLogic 和 OpenNMSd等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2016年Spring RMI反序列化漏洞今年比较出名的：Jackson，FastJson&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;漏洞成因&quot;&gt;漏洞成因&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;POP(property-oriented programming): 控制对象属性然后用它们去影响代码的运行流程。POP gadget就像是高级的ROP，POP组件是在文件中写入数据。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;反序列化的exp并不会直接发送代码让服务器去执行，只是发送&lt;code class=&quot;highlighter-rouge&quot;&gt;服务器已知的类的属性&lt;/code&gt;，然后去操纵那些已经存在的代码以处理这些恶意属性。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;入口点&quot;&gt;入口点&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;序列化对象以&lt;code class=&quot;highlighter-rouge&quot;&gt;ac ed&lt;/code&gt;开始，是magic number。接下来是&lt;code class=&quot;highlighter-rouge&quot;&gt;00 05&lt;/code&gt;，为版本号。接下来应该是0x70到0x7E之间的数，用于描述内容元素的类型，详情见&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/platform/serialization/spec/protocol.html&quot;&gt;Object Serialization Stream Protocol&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;很多IDS靠&lt;code class=&quot;highlighter-rouge&quot;&gt;0xAC ED 00 05&lt;/code&gt;为特征码来判断序列化数据流，但是这几个字节仅出现在最初的序列化传输流里面。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最显著的特征是在数据流里面会有java的类名，如&lt;code class=&quot;highlighter-rouge&quot;&gt;java.rmi.dgc.Lease&lt;/code&gt;，有的形式可能是&lt;code class=&quot;highlighter-rouge&quot;&gt;Ljava/rmi/dgc/VMID;’&lt;/code&gt;。除了类名，还有一些常见的字符串，如&lt;code class=&quot;highlighter-rouge&quot;&gt;sr&lt;/code&gt;可能会代表一个对象（TC_OBJECT）,紧跟着对应的类描述（TC_CLASSDESC）。&lt;code class=&quot;highlighter-rouge&quot;&gt;xp&lt;/code&gt;代表类注释的结束（TC_ENDBLOCKDATA），并且此类没有super class（TC_NULL）。（不太懂，我得再想想）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/2018/03/java//Serialization-oi.png&quot; height=&quot;200&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;序列化对象读取工具：&lt;a href=&quot;https://github.com/NickstaDB/SerializationDumper&quot;&gt;SerializationDumper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;pop-gadgets&quot;&gt;POP Gadgets&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/frohoff/ysoserial/&quot;&gt;ysoserial&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://jackson.thuraisamy.me/runtime-exec-payloads.html&quot;&gt;java.lang.Runtime.exec() Payload Workarounds&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;防御&quot;&gt;防御&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;如何发现反序列化漏洞&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;从流量中发现序列化的痕迹，关键字：ac ed 00 05，rO0AB&lt;/li&gt;
      &lt;li&gt;Java RMI 的传输 100% 基于反序列化，Java RMI 的默认端口是1099端口&lt;/li&gt;
      &lt;li&gt;从源码入手，可以被序列化的类一定实现了Serializable接口&lt;/li&gt;
      &lt;li&gt;观察反序列化时的readObject()方法是否重写，重写中是否有设计不合理，可以被利用之处&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;防范&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;String obj2=(String)ois.readObject();&lt;/code&gt;这种方法并不能奏效，应为强制转换为&lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt;之前readObject()函数就已经运行完毕&lt;/li&gt;
      &lt;li&gt;类白名单校验：在 ObjectInputStream 中 resolveClass 里只是进行了 class 是否能被 load ，自定义 ObjectInputStream , 重载 resolveClass 的方法，对 className 进行白名单校验&lt;/li&gt;
      &lt;li&gt;禁止 JVM 执行外部命令 Runtime.exec&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 17 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/03/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/03/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</guid>
        
        <category>sec</category>
        
        
      </item>
    
      <item>
        <title>面试问题总结</title>
        <description>&lt;h3 id=&quot;阿里-2018-04-09&quot;&gt;阿里 2018-04-09&lt;/h3&gt;

&lt;p&gt;阿里hr面&lt;/p&gt;

&lt;p&gt;本来约了昨天面试哒，好像说面试官小哥哥昨天面了太多人了，没来得及面我T.T差点以为自己被刷了&lt;/p&gt;

&lt;p&gt;自我介绍&lt;/p&gt;

&lt;p&gt;聊了一个项目（全程都是我自己在说，算是项目介绍吧）&lt;/p&gt;

&lt;p&gt;平时怎么学习的&lt;/p&gt;

&lt;p&gt;有什么业余爱好&lt;/p&gt;

&lt;p&gt;从之前的面试中有什么收获&lt;/p&gt;

&lt;p&gt;以后想要从事什么方向的工作&lt;/p&gt;

&lt;p&gt;有自己写过什么大型项目吗&lt;/p&gt;

&lt;h3 id=&quot;阿里-2018-04-04&quot;&gt;阿里 2018-04-04&lt;/h3&gt;

&lt;p&gt;阿里云交叉面&lt;/p&gt;

&lt;p&gt;主要还是围绕简历来问的，大叔给我提了很多中肯的建议&lt;/p&gt;

&lt;p&gt;说我有的项目太学术化，想当然了&lt;/p&gt;

&lt;p&gt;对很多知识点的理解太浅了，不够深入，自己不是特别擅长的东西就不要写在简历上面了&lt;/p&gt;

&lt;p&gt;感觉自己还有好多东西要学哪~&lt;/p&gt;

&lt;h3 id=&quot;阿里-2018-04-03&quot;&gt;阿里 2018-04-03&lt;/h3&gt;

&lt;p&gt;阿里云三面&lt;/p&gt;

&lt;p&gt;CSRF防御，为什么在https跳转到http的时候不带referer？因为https要确保流量全程加密，所以在这种会被抓到包的细微之处也要做好。&lt;/p&gt;

&lt;p&gt;三次握手，syn flood怎么防御。怎么设计UDP让其也有序传输。&lt;/p&gt;

&lt;p&gt;sql注入怎么样防御&lt;/p&gt;

&lt;p&gt;函数调用的汇编流程，一图胜千言吧…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/2018/03/meeting//函数调用.png&quot; height=&quot;400&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看过什么书，怎么学习的&lt;/p&gt;

&lt;p&gt;神经网络的padding，激活函数，过拟合，问的比较简单了&lt;/p&gt;

&lt;p&gt;总体来说还是细节处需要加强，要做算法的话数学功底需要好，概率论和线代要看看，创造力有待培养和提升。&lt;/p&gt;

&lt;h3 id=&quot;阿里-2018-04-02&quot;&gt;阿里 2018-04-02&lt;/h3&gt;

&lt;p&gt;阿里云二面，小哥哥的评价是总体还行，具体细节还需要加强。就算凉了我也是服气的，毕竟自己学的太粗浅了，很多分明知道的东西也不去深究&lt;/p&gt;

&lt;p&gt;HTTP协议解析(是不是这个问题来着…)，反正就是要问burp抓到的包里面HTTP请求头有哪些&lt;/p&gt;

&lt;p&gt;GET、POST、OPTION等请求方式的区别&lt;/p&gt;

&lt;p&gt;XSS在输入检查还是输出编码处防御好&lt;/p&gt;

&lt;p&gt;web指纹技术&lt;/p&gt;

&lt;p&gt;session与cookie的区别&lt;/p&gt;

&lt;h3 id=&quot;腾讯-2018-04-02&quot;&gt;腾讯 2018-04-02&lt;/h3&gt;

&lt;p&gt;腾讯teg的安全云二面，之前那个部门就是挂了啊&lt;/p&gt;

&lt;p&gt;问了我我如何识别垃圾短信&lt;/p&gt;

&lt;p&gt;国民经济平均值报表发出来，大家都说自己达不到平均收入，如何看待&lt;/p&gt;

&lt;p&gt;了解正态分布吗&lt;/p&gt;

&lt;p&gt;鱼妹说我这种面了三个部门的只此一家了，现在总共加起来腾讯有7面了，估计也是凉凉了🤣&lt;/p&gt;

&lt;h3 id=&quot;腾讯-2018-03-30&quot;&gt;腾讯 2018-03-30&lt;/h3&gt;

&lt;p&gt;腾讯四面，还是技术面，让我介绍项目&lt;/p&gt;

&lt;p&gt;最后问了我一个月有31天的话，第二个周三可能是第几天，我回答得太惨了，可能是挂了吧🤣🤣🤣🤣🤣&lt;/p&gt;

&lt;p&gt;鹅厂的面试基本贯穿了我这个月的面试流程，挂了的话是不是可以4月5号笔试之后再面一波🤣🤣🤣🤣🤣&lt;/p&gt;

&lt;p&gt;段少说我可以到时候写个帖子，说鹅厂面了我10面，最后把我给刷了😤😤😤😤😤&lt;/p&gt;

&lt;h3 id=&quot;阿里-2018-03-29&quot;&gt;阿里 2018-03-29&lt;/h3&gt;

&lt;p&gt;下午内推了阿里云盾，当天晚上接到面试电话，面完了才知道面试官是帮我内推的小哥哥🤣&lt;/p&gt;

&lt;p&gt;主要是根据简历来问的，就是想要看里面写的项目是不是真的是自己做的。&lt;/p&gt;

&lt;p&gt;有个问题是问我知不知道语料库如何采集，可能是有什么官方的方法吗，我得查查资料。&lt;/p&gt;

&lt;p&gt;我项目里面的一些代码是直接copy人家git上面的源码，觉得能实现功能就好了，也没深究代码的意义，然后被问得很虚。&lt;/p&gt;

&lt;p&gt;另外我觉得如果想要进某个部门的话，就必须深入了解这个部门的产品线。我可能最近没事就打开云盾主页，看他们家的产品介绍🤣，所以这个小哥哥对我这点还是很满意的&lt;/p&gt;

&lt;p&gt;另外会问优缺点啥的，稍微准备下就好&lt;/p&gt;

&lt;h3 id=&quot;腾讯-2018-03-29&quot;&gt;腾讯 2018-03-29&lt;/h3&gt;

&lt;p&gt;三面是两个大叔，就跟一个大叔聊着聊着，突然又有一个大叔在问我问题，吓哭我😂&lt;/p&gt;

&lt;p&gt;第一个大叔主要还是围绕简历来问，蜜饵文档的制作，我可能还需要回去看看代码了。&lt;/p&gt;

&lt;p&gt;函数怎么压栈，爬虫的多线程代理池自己写过没，用户访问网站会发生什么交互（这边我直接讲了https的握手过程…）&lt;/p&gt;

&lt;p&gt;shell脚本我还需要学习下&lt;/p&gt;

&lt;p&gt;第二个大叔问了我很多深度学习相关的东西，介绍下项目用的模型，然后说我基础不错😊&lt;/p&gt;

&lt;h3 id=&quot;腾讯-2018-03-26&quot;&gt;腾讯 2018-03-26&lt;/h3&gt;

&lt;p&gt;TEG部门小哥哥二面，这个小哥哥好温柔&lt;/p&gt;

&lt;p&gt;技术问题如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ SSRF
+ memcache的drDoS如何防御：
    + memcache使用者：升级最新版本，监听端口随机，将服务放置于可信域内，添加安全组,查看set命令后value的大小是否超过阈值，过滤对外发送的虚假ip报文
    + 被攻击方：流量清洗（how？？？）[互联网创业公司如何防御 DDoS 攻击？](https://www.zhihu.com/question/19581905)
+ 如何审计网站上面的sql注入
+ 如何绕过waf
+ windows保护机制除了GS、ASLR、DEP还有什么，有零页禁用、高熵随机化、[执行流保护（Control Flow Guard , CFG）](http://www.freebuf.com/articles/security-management/58373.html)、管理模式执行保护（Superior Mode Execution Prevention, SMEP）等等。
    [windows安全机制](https://blog.csdn.net/moshangyanyuyao/article/details/17320715)
+ 卷积的原理，为什么高效
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其他就是很多安全学习的问题，为什么要做安全，自己有什么优点（这个我得好好想想，夸夸自己啊），以后的职业规划什么的。&lt;/p&gt;

&lt;h3 id=&quot;腾讯-2018-03-22&quot;&gt;腾讯 2018-03-22&lt;/h3&gt;

&lt;p&gt;TEG部门的小哥哥，问的都是我简历上面的东西，但是想要深入问下去我就都不会了&lt;/p&gt;

&lt;p&gt;最近准备分析个office的宏病毒&lt;/p&gt;

&lt;p&gt;做几个waf绕过的实验&lt;/p&gt;

&lt;h3 id=&quot;腾讯二面-2018-03-20&quot;&gt;腾讯二面 2018-03-20&lt;/h3&gt;

&lt;p&gt;好像被分到支付反欺诈的部门了…小哥哥一直在问机器学习相关的东西…&lt;/p&gt;

&lt;p&gt;搜了下支付安全，没有搜到很多技术文，&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24882985&quot;&gt;从支付宝安全漏洞开始，谈谈机器学习与业务规则，再八卦下人工智能&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;我们来做一个模型，来判断一下当前这个想登录支付宝的用户是不是账号的本人。那么特征工程怎么做呢？考虑的并非仅仅是用户通过了几个安全问题的回答（这个仅仅是实时特征），还有用户基础属性和长期积累的行为。

先不说用户能通过哪几个安全问题，仅仅从用户基础属性和长期行为观察，都可以推测出用户被盗的风险。

举个简单的例子，文化水平低的用户账号容易被盗，在淘宝上经常购买XX商品的用户账号容易被盗，经常在外面开房的用户账号容易被盗等等。

于是乎，提取一堆离线特征，性别，文化水平，区域，购物偏好，酒店订单次数等等.

训练样本也是有的，用户投诉反馈被盗的用户作为正样本，随机挑一些其他用户作为负样本.

然后开始上机器学习算法，贝叶斯，决策树，逻辑回归，gbdt等等，挑挑参，看看ROC和AUC，选择一个最好的上线。

听说做风控的要求变量的可解释性，因此会做一些特征选择方面的工作，比如相关性过高的特征只保留一个。

于是，线上的安全策略模型就是通过账号被盗风险+实时特征（当前网络环境和通过的安全问题）来判断当前用户是账号本人。

比如你的账号被盗风险是0.3，在之前的WIFI下登录，通过了2个安全问题，那么你很可能通过了。

再比如你的账号被盗风险是0.9，在一个全新的WIFI下登录，也许你连回答安全问题的资格都没有。所以，并不是所有人都可以绕过手机验证码，通过回答安全问题进行密码修改的。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;得把机器学习相关的基础知识点好好看看，一个机器学习的具体过程是什么，如何选模型&lt;/p&gt;

&lt;p&gt;审计规则怎么定&lt;/p&gt;

&lt;p&gt;基础算法还是得看看啊，快排什么的&lt;/p&gt;

&lt;p&gt;态势感知到底在做什么&lt;/p&gt;

&lt;p&gt;自己到底擅长什么&lt;/p&gt;

&lt;h3 id=&quot;腾讯-2018-03-16&quot;&gt;腾讯 2018-03-16&lt;/h3&gt;
&lt;p&gt;听完段博士的中期答辩，回到实验室就接到一面电话，还好没回宿舍睡午觉哪…&lt;/p&gt;

&lt;p&gt;总体来说，我感觉自己对很多问题的理解都太浅了，稍微有点深入我就die了，还是得把每个问题扣细了看哪~&lt;/p&gt;

&lt;p&gt;然后虽然我投的是安全岗，但是一些编程相关的基础知识还是得看的。&lt;/p&gt;

&lt;p&gt;1.学过哪些跟安全相关的课程，印象最深的是什么课程，课程里面印象最深的是什么？&lt;/p&gt;

&lt;p&gt;我答了计算机网络，怕其他课程会踩坑，然后讲了DNS的解析过程，DNS劫持、DNS污染。
然后问了DNS劫持和污染不都是劫持吗，怎么去劫持？（我可能是答错了，不仔细看原理的后果很严重&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DNS劫持：&lt;code class=&quot;highlighter-rouge&quot;&gt;劫持了DNS服务器&lt;/code&gt;，通过某些手段取得某域名的解析记录控制权限，进而修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP。解决:使用国外免费公用的DNS服务器，如8.8.8.8&lt;/li&gt;
  &lt;li&gt;DNS污染：让一般用户由于得到虚假目标主机IP而不能与其通信的方法，是一种DNS缓存投毒攻击，一旦发现与关键词相匹配的请求则立即伪装成目标域名的解析服务器给查询者返回虚假结果，直接在&lt;code class=&quot;highlighter-rouge&quot;&gt;协议上&lt;/code&gt;对用户的DNS请求进行干扰。解决:使用VPN&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2.XSS是在&lt;code class=&quot;highlighter-rouge&quot;&gt;前端&lt;/code&gt;执行的，虽然有存储型XSS，但是还是在前端被X啊。会产生哪些影响：cookie劫持、后台增删改文章、钓鱼（利用xss构造出一个登录框，骗取用户账户密码）、xss蠕虫（利用xss漏洞进行传播）、修改网页代码（必须存在存储型xss漏洞，并且将结果返回到页面上）、利用网站重定向、获取用户信息（如浏览器信息，IP地址等）。&lt;/p&gt;

&lt;p&gt;3.CSRF的过程，会读数据吗？CSRF可以读数据，如2007年的Gmail CSRF漏洞，邮箱的Filter中会新创建一条规则，将所有带附件的邮件都转发到攻击者的邮箱中。&lt;/p&gt;

&lt;p&gt;token除了可以放在post包里面，还可以放在那里？用户的Session中，或者浏览器的cookie中。&lt;/p&gt;

&lt;p&gt;4.堡垒机是干什么的？（自己给自己挖的坑吧）
    运维堡垒主机是种具备强大防御功能和安全审计功能的服务器。基于跳板机理念，作为内外网络的个安全审计监测点，以达到把所有网站安全问题集中到某台服务器上解决，从而省时省力。同时运维堡垒主机还具备了，对运维人员的远程登录进行集中管理的功能作用。&lt;/p&gt;

&lt;p&gt;5.python的多线程、&lt;a href=&quot;http://blog.csdn.net/you_are_my_dream/article/details/56316826&quot;&gt;多进程&lt;/a&gt;,可能我还是需要把我辣鸡的小爬虫做成多线程的看看，回答起来才更有底气啊。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;背景：
    &lt;ul&gt;
      &lt;li&gt;GIL(Global Interpreter Lock):全局解释器锁&lt;/li&gt;
      &lt;li&gt;每个CPU在同一时间只能执行一个线程&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;多线程执行方式：
    &lt;ul&gt;
      &lt;li&gt;获取GIL&lt;/li&gt;
      &lt;li&gt;执行代码知道sleep或者是python虚拟机将其挂起&lt;/li&gt;
      &lt;li&gt;释放GIL&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;在Python2.x里，GIL的释放逻辑是当前线程遇见IO操作或者ticks计数达到100，而每次释放GIL锁，线程进行锁竞争、切换线程，会消耗资源&lt;/li&gt;
  &lt;li&gt;是否多线程无用？
    &lt;ul&gt;
      &lt;li&gt;CPU密集型代码（循环、计数等），由于计算工作多，ticks计数很快就会达到阈值，然后触发GIL的释放与再竞争（多个线程来回切换当然是需要消耗资源的），所以python下的多线程对&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU密集型代码并不友好!!!!!!!!&lt;/code&gt;。&lt;/li&gt;
      &lt;li&gt;IO密集型代码（文件处理、爬虫等），多线程能够有效提升效率(单线程下有IO操作会进行IO等待，造成不必要的时间浪费，而开启多线程能在线程A等待时，自动切换到线程B，可以不浪费CPU的资源，从而能提升程序执行效率)。所以python的多线程对&lt;code class=&quot;highlighter-rouge&quot;&gt;IO密集型代码比较友好&lt;/code&gt;。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;多核多线程比单核多线程更差，原因是单核下多线程，每次释放GIL，唤醒的那个线程都能获取到GIL锁，所以能够无缝执行，但多核下，CPU0释放GIL后，其他CPU上的线程都会进行竞争，但GIL可能会马上又被CPU0拿到，导致其他几个CPU上被唤醒后的线程会醒着等待到切换时间后又进入待调度状态，这样会造成线程颠簸(thrashing)，导致效率更低&lt;/li&gt;
  &lt;li&gt;python下想要充分利用多核CPU，就用多进程,每个进程有各自独立的GIL，互不干扰，这样就可以真正意义上的并行执行，所以在python中，多进程的执行效率优于多线程(仅仅针对多核CPU而言)。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;6.&lt;a href=&quot;http://tech.ifeng.com/a/20180305/44895634_0.shtml&quot;&gt;DrDDoS&lt;/a&gt;为什么能放大5w倍：
Memcached的key-value功能。前文提到key-value的作用是决定存储容量的大小，正常情况下key-value的值通常不超过几千字节。当Memcached被攻击者利用作为反射器时，key-value的值经过修改可以达到100万字节以上。&lt;/p&gt;

&lt;p&gt;http://www.freebuf.com/vuls/164864.html&lt;/p&gt;

&lt;p&gt;7.C++ 为什么能继承（这个我再想想，可能我是把问题听错了）&lt;/p&gt;

&lt;p&gt;8.windows防御机制，哪个是第一个出现的？ASLR、DEP、GS&lt;/p&gt;

&lt;p&gt;9.Java反序列化，这个我要去具体分析几个poc了，要不然说起来真是没底气啊&lt;/p&gt;

&lt;p&gt;10.平时会看书吗？我说了在看兜哥的《web安全深度学习实战》，问我具体的章节问题，里面的demo我都还没试啊，懒惰如我…&lt;/p&gt;

&lt;p&gt;11.做过渗透测试吗：准备做一些 &lt;a href=&quot;hackthebox.eu&quot;&gt;hackbox&lt;/a&gt;上面的题目弥补无渗透经验的缺陷T.T&lt;/p&gt;
</description>
        <pubDate>Fri, 16 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/03/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/03/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/</guid>
        
        <category>sec</category>
        
        
      </item>
    
      <item>
        <title>字符集以及转义编码相关问题</title>
        <description>&lt;p&gt;###&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;GB2312 , GBK , GB18030 , BIG5 , SHIFT_JIS 等这些都是常说的宽字节（两个字节），ascii就是单字节（一个字节）
      + 呼吁所有的程序都使用unicode编码，所有的网站都使用utf-8编码
      + 一个gbk编码汉字，占用2个字节。一个utf-8编码的汉字，占用3个字节&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;常用&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  %20 -&amp;gt; 0x20 -&amp;gt; 空格
  %23 -&amp;gt; 0x23 -&amp;gt; #
  %0d -&amp;gt; 0x0d -&amp;gt; CR \r 
  %0a -&amp;gt; 0x0a -&amp;gt; LF \n
  %08 -&amp;gt; 0x08 -&amp;gt; BS
  %00 -&amp;gt; 0x00 -&amp;gt; Null Byte
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 12 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/03/%E5%AD%97%E7%AC%A6%E9%9B%86%E7%9B%B8%E5%85%B3/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/03/%E5%AD%97%E7%AC%A6%E9%9B%86%E7%9B%B8%E5%85%B3/</guid>
        
        <category>计算机基础</category>
        
        
      </item>
    
  </channel>
</rss>
